/*******************************************************************************************************
INFORMATION -- READ ME
*******************************************************************************************************
Script name :
	CharacterGenerator_FbxToBiped.ms
Script description :
	This script converts an fbx rig to a 3ds Max Character Studio Biped rig.
	This script supports fbx files generated by Autodesk Character Generator for import into Autodesk 3ds Max for use with bipeds.
	ANY OTHER USAGE IS NOT SUPPORTED.
Assumptions :
	This script is based on the naming convention and bone structure built by Autodesk Character Generator published .fbx files for 3ds Max bipeds, using the following options.
	Skeleton Resolution : Biped.
	File format : 3ds Max, MotionBuilder, others (.fbx).
	Facial Expressions : None,  Facial blend shapes, or Facial bone rig.
	Poly Resolutions : Any combination of Poly Resolutions.
	http://charactergenerator.autodesk.com
Script compatibility :
	Autodesk 3ds Max versions 2013, 2014, 2015.
How to use :
	1) Start a new empty 3ds Max scene.
	2) Import the .fbx file published by the Autodesk Character Generator.
	3) Run the script and wait for 100% completion.
	4) Save your Scene and Enjoy animating using Autodesk 3ds Max Character Studio Biped.
Nota :
	Using this script after importing the fbx file into 3ds Max via the drag and drop fbx import feature will move character into the center of the scene.
	The drag and drop fbx import is supported when importing in :
		- Perspective View
		- Orthographic View
		- Orthographic Top View
		- Orthographic Bottom View
Author :
	jean-thierry.roy@autodesk.com for Autodesk Character Generator 3ds Max users.
Date :
	October/November 2013 -- v1.0 Script creation
	Febuary 2014 -- v1.2 Fix issues with some specific stances for legs
	April 2014 -- v1.3 Fix ** system exception ** error on some configs
	May 2014 -- v1.4 Fix Head Nub duplication for Animation Store animation import
	May 2014 -- v1.5 Added support for Drag and Drop FBX import into viewport workflow
*********************************************************************************************************
Please post Issues and Comments in Autodesk's forum for Character Generator.
http://forums.autodesk.com/t5/Character-Generator-General/bd-p/charactergeneratordiscussion
*********************************************************************************************************
****************** >>> In courtesy to 3ds Max Character Studio Biped users <<<
*********************************************************************************************************
****************** >>> Copyright Autodesk (c) 2014, All Rights Reserved. <<<
*********************************************************************************************************
Autodesk, 3ds Max, and Character Generator are registered trademarks or trademarks of Autodesk, Inc.,
and/or its subsidiaries and/or affiliates in the USA and/or other countries.
(c) 2014 Autodesk, Inc. All rights reserved.
Use of this software is subject to the terms of the Autodesk license agreement provided at the time of installation or download,
or which otherwise accompanies this software in either electronic or hard copy form.
**********************************************************************************************************/
pushPrompt "1 % - Checking positions"

( -- Get meshes position
/*
for Drag And Drop FBX into viewport workflow
Get incoming meshes position so can be centered after getting skin data
*/
clearSelection()
select $'H_DDS_*'
myBaseMeshes = #()
for i in selection do (
	append myBaseMeshes i
	)
clearSelection()
global myRefMesh = myBaseMeshes[1]
global myRefOffSetX = (myRefMesh.position.x)*-1
global myRefOffSetY = (myRefMesh.position.y)*-1
global myRefOffSetZ = (myRefMesh.position.z)*-1

global myRefFBXRootX = $'Fbx01'.position.x
global myRefFBXRootY = $'Fbx01'.position.y
global myRefFBXRootZ = $'Fbx01'.position.z
/*
$'Fbx01'.position.x = (myRefFBXRootX - myRefOffSetX)
$'Fbx01'.position.y = (myRefFBXRootY - myRefOffSetY)
$'Lights'.position.x = (myRefFBXRootX - myRefOffSetX)
$'Lights'.position.y = (myRefFBXRootY - myRefOffSetY)
*/

)-- Check mesh position and center if necessary (for Drag And Drop FBX into viewport workflow)

pushPrompt "2 % - Defining"

function myBodyparts =
( -- defining body parts
-- defining each body parts suffixes for alignment, each have a root node[1] that needs position and each may have various up vectors
-- using prefixes for get/set nodes by name
global myBip = "Bip01"
global myFbx = "Fbx01"
-- body parts
-- root and pelvis
global myRoot = #("", " Pelvis")
-- Spine needs Pos[1] Rot Scale
global mySpine = #(" Spine", " Spine1", " Spine2", " Spine3", " Neck")
if $'Fbx01_Spine3' == undefined do (mySpine = #(" Spine", " Spine1", " Spine2"," Neck"))
-- Neck needs Pos[1] Rot Scale
global myNeck = #(" Neck", " Neck1", " Head", " HeadNub")
if $'Fbx01_Neck1' == undefined do (myNeck = #(" Neck", " Head", " HeadNub"))
-- Arm needs Pos[1] Rot Scale
global myArm = #(" R Clavicle", " R UpperArm", " R Forearm", " R Hand", " R Finger2")
-- Hand needs Pos[1] Rot with 2 targets @50 Scale
global myHand = #(" R_Hand", " R Finger2", " R Finger3")
-- fingers need Pos[1] rot.Z Scale
global myFing1 = #(" R Finger1", " R Finger11", " R Finger12", " R Finger1Nub")
global myFing2 = #(" R Finger2", " R Finger21", " R Finger22", " R Finger2Nub")
global myFing3 = #(" R Finger3", " R Finger31", " R Finger32", " R Finger3Nub")
global myFing4 = #(" R Finger4", " R Finger41", " R Finger42", " R Finger4Nub")
global myThumb = #(" R Finger0", " R Finger01", " R Finger02", " R Finger0Nub")
-- Leg needs Pos[1] Rot Scale
global myLeg = #(" R Thigh", " R Calf", " R Foot")
-- Foot needs Pos Scale
global myFoot =#(" R Foot", " R Toe0", " R Toe0Nub")
)
myBodyparts()

-- list of all skinned meshes
( -- parsing all meshes in scene and assigning to array
myMeshesPrefixes = #()
myMeshesPrefixes = #($'h_*', $'l_*', $'c_*', $'m_*')
global mySkinedMeshes = #()
for i in myMeshesPrefixes do (
	for j in i do (
		if (j.modifiers[#skin]) != undefined do (
			append mySkinedMeshes j
			)
		)
	)
)
mySkinedMeshes.count


function boneRenamer myTempName inPrefix outPrefix = (
	if matchPattern myTempName pattern:(inPrefix+"*") == true do
		(myTempName = replace myTempName 1 inPrefix.count outPrefix)
	return myTempName
	)
-- remane using the prefix renamer boneRenamer()

pushPrompt "5 % - Extracting skin data"

(-- rename fbx01 to bip01 and extract skindata mesh and rename bip01 to fbx01

( -- rename incoming Fbx rig with " " (spaces) instead of "_" (underscores) so the skin ops transfer can be scripted without having to script the bone mapping
max unfreeze all
function replaceSpace myStrg =
	(
	for i = 1 to myStrg.count do (
		if myStrg[i] == "_" then (
			myStrg[i] = " "
			)
		)
	return myStrg
	)

function renameRig =
	(
	select $'Fbx01' ; actionMan.executeAction 0 "40180"
	myObjs = $
	myObjs.count
	for i = 1 to myObjs.count do (
		myObjs[i].name = replaceSpace(myObjs[i].name)
		)
	clearSelection()
	)
renameRig()
	)

function renameRigData myOld myNew =
	(
	select (getNodeByName(myOld)) ; actionMan.executeAction 0 "40180"
	myObjs = $
	myObjs.count
	for i = 1 to myObjs.count do (
		myObjs[i].name = boneRenamer myObjs[i].name myOld myNew
		)
	clearSelection()
	)
renameRigData myFbx myBip


(--list all bones per mesh
/* Array of arrays of bones */
global mySkinnedMeshesBonesArr = #()
max modify mode
for i=1 to mySkinedMeshes.count do (
	myTestMesh = mySkinedMeshes[i]
	-- get all bones from the mesh Skin modifier
		select myTestMesh
		boneCount = skinOps.GetNumberBones myTestMesh.modifiers[#Skin]
		SkinBones = #()
		for b=1 to boneCount do (
			append SkinBones (skinOps.GetBoneName myTestMesh.modifiers[#Skin] b 1)
			)
		print SkinBones
	append mySkinnedMeshesBonesArr SkinBones
	)

) --list all bones per mesh

-- Extract skin data
for i in mySkinedMeshes do (
	skinUtils.ExtractSkinData i
	myTempDelMod = i.modifiers[#Skin]
	deleteModifier i myTempDelMod
	)

-- rename rig back to fbx
renameRigData myBip myFbx

)-- rename fbx01 to bip01 and extract skindata mesh and rename bip01 to fbx01

( -- Center objects in scene

-- move all skinned meshes
for i=1 to mySkinedMeshes.count do (
	move mySkinedMeshes[i] [myRefOffSetX, myRefOffSetY, 0]
	)
-- move fbx rig
move $'Fbx01' [myRefOffSetX, myRefOffSetY, 0]

-- move lights root
move $'Lights' [myRefOffSetX, myRefOffSetY, 0]

-- move skindata meshes
mySkindataMeshes = #()
mySkindataMeshes = $'SkinData_*'
mySkindataMeshes.count
for i= 1 to mySkindataMeshes.count do (
	move mySkindataMeshes[i] [myRefOffSetX, myRefOffSetY, 0]
	)

) -- Center objects in scene


pushPrompt "8 % - Setting up for Biped"

(-- create a point per fbx bone for biped alignment.

-- myPointDisplay = On
global myPointDisplay = Off
-- setting up reference points for position and rotation of biped
function myHelpRot inPos inTrg inUpAx =
	(
	-- create  point helper for alignment
	myName = ("myPoint "+inPos.name)
	myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:inPos.position isSelected:off
	-- set constraint
	myObj.rotation.controller = LookAt_Constraint ()
	-- set target
	myObj.rotation.controller.appendTarget inTrg 50.0
	-- set initial offset
	myObj.rotation.controller.relative = false
	-- set target axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.target_axis = 0
	myObj.rotation.controller.target_axisFlip = false
	-- set up world
	myObj.rotation.controller.upnode_world = true
	-- set up node axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.StoUP_axis = inUpAx[1]
	myObj.rotation.controller.StoUP_axisFlip = inUpAx[2]
	-- set upnode axis alignment
	myObj.rotation.controller.upnode_axis = inUpAx[3]
	-- get point`s world matrix
	myMatrix = myObj.transform
	myObj.rotation.controller = Euler_XYZ()
	myObj.transform = myMatrix
	)

-- setting up reference points for position and rotation of biped Hand specific 2 targets
function myHelpRotHand inPos inTrg1 inTrg2 inUpAx =
	(
	-- create  point helper for alignment
	myName = ("myPoint "+inPos.name)
	myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:inPos.position isSelected:off
		print myName
	-- set constraint
	myObj.rotation.controller = LookAt_Constraint ()
	-- set target
	myObj.rotation.controller.appendTarget inTrg1 50.0
	myObj.rotation.controller.appendTarget inTrg2 50.0
	-- set initial offset
	myObj.rotation.controller.relative = false
	-- set target axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.target_axis = 0
	myObj.rotation.controller.target_axisFlip = false
	-- set up world
	myObj.rotation.controller.upnode_world = true
	-- set up node axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.StoUP_axis = inUpAx[1]
	myObj.rotation.controller.StoUP_axisFlip = inUpAx[2]
	-- set upnode axis alignment
	myObj.rotation.controller.upnode_axis = inUpAx[3]
	-- get point`s world matrix
	myMatrix = myObj.transform
	myObj.rotation.controller = Euler_XYZ()
	myObj.transform = myMatrix
	)

(-- set Up helper for leg & foot
myUpName = "myPoint Up"
global myUpPoint = Point name:myUpName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:(getNodeByName(myFbx + myFoot[1])).position isSelected:off
myUpPoint.rotation.controller = LookAt_Constraint ()
myUpPoint.rotation.controller.appendTarget (getNodeByName(myFbx + myFoot[2])) 50.0
myMatrix = myUpPoint.transform
myUpPoint.rotation.controller = Euler_XYZ()
myUpPoint.transform = myMatrix
myX = (2*(length((getNodeByName(myFbx + myFoot[1])).position - (getNodeByName(myFbx + myFoot[2])).position)))
myZ =  ((getNodeByName(myFbx + myFoot[1])).position.z)
in coordsys #local move myUpPoint [myX,0,0]
in coordsys #world myUpPoint.position.z = myZ
)

-- setting points for leg and foot
function myHelpRotLeg inPos inTrg inUpAx =
	(
	-- create  point helper for alignment
	myName = ("myPoint "+inPos.name)
	myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:inPos.position isSelected:off
	-- set constraint
	myObj.rotation.controller = LookAt_Constraint ()
	-- set target
	myObj.rotation.controller.appendTarget inTrg 50.0
	-- set initial offset
	myObj.rotation.controller.relative = false
	-- set target axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.target_axis = inUpAx[3]
	myObj.rotation.controller.target_axisFlip = false
	-- set up world
	myObj.rotation.controller.upnode_world =  inUpAx[4]
	myObj.rotation.controller.pickUpNode = myUpPoint
	-- set up node axis ( axis 0=x 1=y 2=z)
	myObj.rotation.controller.StoUP_axis = inUpAx[1]
	myObj.rotation.controller.StoUP_axisFlip = inUpAx[2]
	myObj.rotation.controller.upnode_ctrl = inUpAx[5]
	--get&set point`s world matrix
	myMatrix = myObj.transform
	myObj.rotation.controller = Euler_XYZ()
	myObj.transform = myMatrix
	)

-- set spine
for i = 1 to mySpine.count-1 do (
	myPos = (getNodeByName (myFbx + mySpine[i]))
	myTarget = (getNodeByName (myFbx + mySpine[i+1]))
	myUpAxis = #(1,true,1)
	myHelpRot myPos myTarget myUpAxis
	)

-- set neck
for i = 1 to myNeck.count do (
	if i < myNeck.count do
		(
		myPos = (getNodeByName (myFbx + myNeck[i]))
		myTarget = (getNodeByName (myFbx + myNeck[i+1]))
		myUpAxis = #(1,true,1)
		myHelpRot myPos myTarget myUpAxis
		)
	if i == myNeck.count do
		(
		myPos = (getNodeByName (myFbx + myNeck[i])).position
		myName = ("myPoint " + myFbx + myNeck[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		)
	)



-- set right leg
for i = 1 to myLeg.count-1 do (
	myPos = (getNodeByName (myFbx + myLeg[i]))
	myTarget = (getNodeByName (myFbx + myLeg[i+1]))
	myUpAxis = #(1,false,0,false,0)
	myHelpRotLeg myPos myTarget myUpAxis
	)

-- set right foot
for i = 1 to myFoot.count do (
	if i == 1 do
		(
		myPos = (getNodeByName (myFbx + myFoot[i]))
		in coordsys #world myUpPoint.position.z = (getNodeByName (myFbx + myFoot[i])).position.z
		myTarget = myUpPoint
		myUpAxis = #(2,true,1,true,1)
		myHelpRotLeg myPos myTarget myUpAxis
		)
	if i == 2 do
		(
		myPos = (getNodeByName (myFbx + myFoot[i]))
		in coordsys #world myUpPoint.position.z = (getNodeByName (myFbx + myFoot[i])).position.z
		myTarget = myUpPoint
		myUpAxis = #(1,false,0,true,1)
		myHelpRotLeg myPos myTarget myUpAxis
		)
	if i == myFoot.count do
		(
		myPos = (getNodeByName (myFbx + myFoot[i])).position
		myName = ("myPoint " + myFbx + myFoot[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		)
	)

-- set right arm
for i = 1 to myArm.count-2 do (
	myPos = (getNodeByName (myFbx + myArm[i]))
	myTarget = (getNodeByName (myFbx + myArm[i+1]))
	myUpAxis = #(1,false,1)
	myHelpRot myPos myTarget myUpAxis
	)

-- set hand with special case function
( -- hand is a special case, look at 2 targets
myHelpRotHand (getNodeByName (myFbx + myHand[1])) (getNodeByName (myFbx + myHand[2])) (getNodeByName (myFbx + myHand[3])) #(2,true,1)
)

-- setting finger 1
for i = 1 to myFing1.count do (
	if i < myFing1.count do
		(
		myPos = (getNodeByName (myFbx + myFing1[i]))
		myTarget = (getNodeByName (myFbx + myFing1[i+1]))
		myUpAxis = #(1,true,1)
		myHelpRot myPos myTarget myUpAxis
		)
	if i == myFing1.count do
		(
		myPos = (getNodeByName (myFbx + myFing1[i-1])).position
		myName = ("myPoint " + myFbx + myFing1[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		in coordsys (getNodeByName ("myPoint " + myFbx + myFing1[i-1])) (getNodeByName ("myPoint " + myFbx + myFing1[i])).rotation = (getNodeByName ("myPoint " + myFbx + myFing1[i-1])).rotation
		(getNodeByName ("myPoint " + myFbx + myFing1[i])).position = (getNodeByName (myFbx + myFing1[i])).position
		)
	)

for i = 1 to myFing2.count do (
	if i < myFing2.count do
		(
		myPos = (getNodeByName (myFbx + myFing2[i]))
		myTarget = (getNodeByName (myFbx + myFing2[i+1]))
		myUpAxis = #(1,true,1)
		myHelpRot myPos myTarget myUpAxis
		)
	if i == myFing2.count do
		(
		myPos = (getNodeByName (myFbx + myFing2[i-1])).position
		myName = ("myPoint " + myFbx + myFing2[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		in coordsys (getNodeByName ("myPoint " + myFbx + myFing2[i-1])) (getNodeByName ("myPoint " + myFbx + myFing2[i])).rotation = (getNodeByName ("myPoint " + myFbx + myFing2[i-1])).rotation
		(getNodeByName ("myPoint " + myFbx + myFing2[i])).position = (getNodeByName (myFbx + myFing2[i])).position
		)
	)

for i = 1 to myFing3.count do (
	if i < myFing3.count do
		(
		myPos = (getNodeByName (myFbx + myFing3[i]))
		myTarget = (getNodeByName (myFbx + myFing3[i+1]))
		myUpAxis = #(1,true,1)
		myHelpRot myPos myTarget myUpAxis
		)
	if i == myFing3.count do
		(
		myPos = (getNodeByName (myFbx + myFing3[i-1])).position
		myName = ("myPoint " + myFbx + myFing3[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		in coordsys (getNodeByName ("myPoint " + myFbx + myFing3[i-1])) (getNodeByName ("myPoint " + myFbx + myFing3[i])).rotation = (getNodeByName ("myPoint " + myFbx + myFing3[i-1])).rotation
		(getNodeByName ("myPoint " + myFbx + myFing3[i])).position = (getNodeByName (myFbx + myFing3[i])).position
		)
	)

for i = 1 to myFing4.count do (
	if i < myFing4.count do
		(
		myPos = (getNodeByName (myFbx + myFing4[i]))
		myTarget = (getNodeByName (myFbx + myFing4[i+1]))
		myUpAxis = #(1,true,1)
		myHelpRot myPos myTarget myUpAxis
		)
	if i == myFing4.count do
		(
		myPos = (getNodeByName (myFbx + myFing4[i-1])).position
		myName = ("myPoint " + myFbx + myFing4[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		in coordsys (getNodeByName ("myPoint " + myFbx + myFing4[i-1])) (getNodeByName ("myPoint " + myFbx + myFing4[i])).rotation = (getNodeByName ("myPoint " + myFbx + myFing4[i-1])).rotation
		(getNodeByName ("myPoint " + myFbx + myFing4[i])).position = (getNodeByName (myFbx + myFing4[i])).position
		)
	)

for i = 1 to myThumb.count do (
	if i < myThumb.count do
		(
		myPos = (getNodeByName (myFbx + myThumb[i]))
		myTarget = (getNodeByName (myFbx + myThumb[i+1]))
		myUpAxis = #(2,true,2)
		myHelpRot myPos myTarget myUpAxis
		in coordsys (getNodeByName ("myPoint " + myFbx + myThumb[i])) (rotate (getNodeByName ("myPoint " + myFbx + myThumb[i])) (angleaxis 90 [1,0,0]))
		)
	if i == myThumb.count do
		(
		myPos = (getNodeByName (myFbx + myThumb[i-1])).position
		myName = ("myPoint " + myFbx + myThumb[i])
		myObj = Point name:myName centermarker:off axistripod:myPointDisplay cross:off box:myPointDisplay pos:myPos isSelected:off
		in coordsys (getNodeByName ("myPoint " + myFbx + myThumb[i-1])) (getNodeByName ("myPoint " + myFbx + myThumb[i])).rotation = (getNodeByName ("myPoint " + myFbx + myThumb[i-1])).rotation
		(getNodeByName ("myPoint " + myFbx + myThumb[i])).position = (getNodeByName (myFbx + myThumb[i])).position
		)
	)

	) -- create a point per fbx bone for biped alignment.

pushPrompt "10 % - Creating Biped rig"

(-- biped creation
myBipHeight = $Fbx01.position.z*2.2
myBipPos = $Fbx01.position
biped.createNew myBipHeight -90.0 myBipPos neckLinks:(myNeck.count-2) spineLinks:(mySpine.count-1) fingers:5 fingerLinks:3 toes:1 toeLinks:1

myBiped=$bip001.controller
myBiped.rootName = "Bip01"
myBiped.bodyType = 3
myBiped.figureMode = True
	) -- biped creation

pushPrompt "15 % - Aligning Biped to Skeleton"

(-- setting center of mass position // Root
biped.setTransform $'Bip01' #rotation ($'Fbx01'.rotation*(quat 0 0 1 0)) False
biped.setTransform $'Bip01' #pos [$'Fbx01'.position.x, $'Fbx01 R Thigh'.position.y, $Fbx01.position.z] False
	) -- setting center of mass position // Root

(-- setting pelvis scale to position thighs
myPelvisScale = $'Fbx01 L Thigh'.position.x*2
biped.setTransform $'Bip01 Pelvis' #scale [myPelvisScale, myPelvisScale, myPelvisScale] False
	) -- setting pelvis scale to position thighs

( -- biped aligner
function myPosition Src Tgt =
	(
	biped.setTransform Src #pos (Tgt.position) False
	)
myPosition $'Bip01 R Finger41' $'Fbx01_R_Finger41'

function myRotation Src Tgt =
	(
	myRot = (in coordsys Src Tgt.rotation as eulerAngles) as angleAxis
	in coordsys Src rotate Src myRot
	)
myRotation $'Bip01 Spine1' $'Fbx01 Spine1'


function myScale Src1 Src2 Tgt =
	(
	myLength = length (Src1.position - Src2.position)
	biped.setTransform Tgt #scale [myLength, myLength, myLength] False
	)
myScale $'Fbx01_R_Finger42' $'Fbx01_R_Finger4Nub' $'Bip01 R Finger42'


function myAligner myAlignedParts = (
	myPosition (getNodeByName (myBip + myAlignedParts[1])) (getNodeByName ("myPoint " + myFbx + myAlignedParts[1]))
	for i=1 to myAlignedParts.count-1 do (
		myScale (getNodeByName ("myPoint " + myFbx + myAlignedParts[i])) (getNodeByName ("myPoint " + myFbx + myAlignedParts[i+1])) (getNodeByName (myBip + myAlignedParts[i]))
		myRotation (getNodeByName (myBip + myAlignedParts[i])) (getNodeByName ("myPoint " + myFbx + myAlignedParts[i]))
		)
)

function myAlignerFoot myAlignedParts2 = (
	myPosition (getNodeByName (myBip + myAlignedParts2[1])) (getNodeByName ("myPoint " + myFbx + myAlignedParts2[1]))
	for i=1 to myAlignedParts2.count-1 do (
		myLengthx = (getNodeByName ("myPoint " + myFbx + myAlignedParts2[i])).position.z
		myLengthy = (getNodeByName ("myPoint " + myFbx + myAlignedParts2[i+1])).position.y
		myRotation (getNodeByName (myBip + myAlignedParts2[i])) (getNodeByName ("myPoint " + myFbx + myAlignedParts2[i]))
		if i == 1 do (
			biped.setTransform (getNodeByName (myBip + myAlignedParts2[i])) #scale [myLengthx, myLengthy, myLengthx] False
			)
		if i == 2 do (
			biped.setTransform (getNodeByName (myBip + myAlignedParts2[i])) #scale [(3*myLengthx), (1.5*myLengthx), (3*myLengthx)] False
			)
		)
)

myAligner mySpine
myAligner myNeck
myAligner myArm
myAligner myLeg
myAlignerFoot myFoot
myAligner myHand
myAligner myFing1
myAligner myFing2
myAligner myFing3
myAligner myFing4
myAligner myThumb

(-- copy right to left leg mirror
biped.createCopyCollection $'Bip01'.controller "myCollection"
select $'Bip01 R Thigh'
actionMan.executeAction 0 "40180"
myThigh = biped.copyPosture $'Bip01 R Thigh'.controller #posture True True True
biped.pastePosture $'Bip01 L Thigh'.controller #posture True myThigh
clearSelection()
	) -- copy right to left leg mirror

( -- copy right to left arm mirror
select $'Bip01 R Clavicle'
actionMan.executeAction 0 "40180"
myArm = biped.copyPosture $'Bip01 R UpperArm'.controller #posture True True True
biped.pastePosture $'Bip01 L UpperArm'.controller #posture True myArm
clearSelection()
	) -- copy right to left arm mirror

( -- copy body pose
select $'Bip01'
actionMan.executeAction 0 "40180"
biped.copyPosture $'Bip01 R UpperArm'.controller #posture True True True

clearSelection()
	) -- copy right to left arm mirror

	) -- biped aligner

pushPrompt "20% Transfering Skin weights ..."

( -- skining transfer and facial bones transfer
myPushPrompt = (20 as string) + "% Transfering Skin weights"
pushPrompt myPushPrompt
(-- find all facial bones and rename to Bip
clearSelection()
select $'Fbx01 HeadNub'
delete $
select $'Fbx01 Head'
max select child
mySel = $
for i=1 to mySel.count do (
	print mySel[i].name
	print myFbx
	print (matchPattern mySel[i].name pattern:(myFbx + "*"))
	if (matchPattern mySel[i].name pattern:(myFbx + "*")) == true do (
		mySel[i].name = boneRenamer mySel[i].name myFbx myBip
		)
	)
) -- find all facial bones and rename to Bip

(-- reparent facial bones to biped
select $'Fbx01 Head'
max select child
mySel = $
for i=1 to mySel.count do (
	mySel[i].parent = getNodeByName(myBip + myNeck[3])
)
)-- reparent facial bones to biped

-- parses all meshes and process skin transfer
max modify mode

for i=1 to mySkinedMeshes.count do (
-- per mesh operations
myTestMesh = mySkinedMeshes[i]

myPushPrompt = ((20 + (75/mySkinedMeshes.count)*(i)) as string) + "% Transfering Skin weights : " + myTestMesh.name
pushPrompt myPushPrompt

-- select mesh to operate on
select myTestMesh
-- add new skin modifier
modPanel.addModToSelection (Skin ()) ui:on

-- add bones
SkinBones = mySkinnedMeshesBonesArr[i]
for i = 1 to SkinBones.count do (
	skinOps.addbone $.modifiers[#Skin] (getNodeByName(SkinBones[i])) 0
)

(-- importing skin weights back new method by having extracted skindata as Bip01 bones - match by name only !
global myMeshIs = myTestMesh.name
global myMeshSkinIs = "SkinData_" + myMeshIs
select #(getNodeByName(myMeshIs), getNodeByName(myMeshSkinIs))
skinUtils.ImportSkinDataNoDialog True False False False False 1.0 0
) -- importing skin weights back new method

	) -- parses all meshes and process skin transfer

)  -- skining transfer  and facial bones transfer

pushPrompt "95% Cleaning up ..."

( -- clean up scene ready to be saved and used
$'Bip01'.controller.figureMode = false
max unfreeze all
delete $'myPoint*'
delete $'SkinData_*'
delete $'Fbx01*'
select $*Nub
max freeze selection
select $'Bip01 Footsteps'
max freeze selection
)	-- clean up scene ready to be saved and used

-- garbage collection
gc()
freescenebitmaps()
clearUndoBuffer()
/*clearlistener()*/
"100% Transfer completed."
pushPrompt "100% Transfer completed."
completeRedraw()
-- prompt user transfer done.
messageBox "Fbx rig to Character Studio Biped is completed." title:"Fbx To Biped - Autodesk Character Generator"
